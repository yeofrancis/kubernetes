
## Crafting Your Own Docker Image

### Part A: Concept

Dockerfile

   A text file named Dockerfile that contains a step-by-step recipe for building your image.
   Each line is an instruction—like “start from this base,” “copy these files,” and “run this command.”

Build

   docker build reads your Dockerfile and produces a new image.
   You tag that image (give it a friendly name) so you can run it later.

Run with Port Mapping

   Often your app listens on a port (e.g., 80). To reach it from the host, you map a host port (8080) to the container port (80) via -p

### Part B: Hands-On

  Create a project folder

  ```
mkdir ~/docker-101
cd ~/docker-101
```
  Write a simple HTML page
  Create index.html with:
```
<html>
  <head><title>My Docker Site</title></head>
  <body>
    <h1>Hello from my custom Docker image!</h1>
  </body>
</html>
```
  Create your Dockerfile
  In the same folder, make a file named Dockerfile (no extension) with:
```
# Use the lightweight NGINX image
FROM nginx:alpine

# Remove the default page and add yours
COPY index.html /usr/share/nginx/html/index.html

# Expose port 80
EXPOSE 80
```
  Build the image
```
docker build -t my-static-site .
```
   - -t my-static-site tags your image as my-static-site:latest
   - The final . tells Docker to use the current folder (and Dockerfile) as context.

  Run the container
```
docker run -d --name site -p 8080:80 my-static-site
```
   - -d runs it in the background
   - --name site gives it a friendly name
   - -p 8080:80 maps your machine’s port 8080 → container’s port 80

  Cleanup
```
docker stop site
docker rm site
```

### Part C: Reflect
 1. My Three takeaways:
   -   What did you learn about the structure of a Dockerfile?

       Dockerfile = Blueprint for Your Image

       - A Dockerfile is a step-by-step recipe that tells Docker how to build an image.
       - Each instruction (FROM, RUN, COPY, etc.) creates a layer, so Docker can cache and reuse unchanged steps.
       - When you run docker build, Docker reads this file top-to-bottom, applies each layer, and spits out a ready-to-run image containing everything your app needs.
       
   -   How does Docker use the COPY instruction?
     
       COPY = Copying Files into Your Image
       - The COPY <src> <dest> instruction takes files or folders from your build context (the directory you specify to docker build) and places them into the image’s filesystem at <dest>.
       - It’s how you bundle your app’s code, configuration, or static assets into the container.
       - Under the hood, Docker adds a new layer containing those files—so if only your source code changes, only that layer needs rebuilding next time.          

   -   Why do we need -p 8080:80 when running?
     
       -p 8080:80 = Port Mapping for External Access
       - Containers are isolated by default—ports inside them aren’t reachable from your host machine.
       - The -p <hostPort>:<containerPort> flag tells Docker to forward traffic from port 8080 on your PC to port 80 inside the container.
       - This way, when you browse to http://localhost:8080, Docker routes that request into the container’s web server listening on port 80.

 2. Quick quiz

   -   What command builds an image from your Dockerfile?

   -   How would you run that image so you can access it on port 5000 instead?

 3. Rubber-duck moment
  Explain to your “duck” how Docker goes from your Dockerfile to serving a website in the browser.


